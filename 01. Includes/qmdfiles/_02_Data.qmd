---
format: html
---

## Laad de data

We laden een subset in van historische data specifiek voor:

**Opleiding**: `r params$faculteit` \| `r params$opleidingsnaam` (`r params$opleiding`), `r params$opleidingsvorm`, eerstejaars - **`r sUitval_model`**

```{r}
## Laad de data voor de HBO-V opleiding
dfOpleiding_inschrijvingen_base <- get_lta_studyprogram_enrollments_pin(
    board = "HHs/Inschrijvingen",
    faculty = faculteit,
    studyprogram = opleidingsnaam_huidig,
    studytrack = opleiding,
    studyform = toupper(opleidingsvorm),
    range = "eerstejaars")

## Herschik de levels
Set_Levels(dfOpleiding_inschrijvingen_base)

dfOpleiding_inschrijvingen_base <- dfOpleiding_inschrijvingen_base |>  
  
  ## Maak een eenvoudige Uitval variabele aan
  Mutate_Uitval(sUitval_model) |>
  
  ## Maak van de uitval variabele een factor
  mutate(SUC_Uitval = as.factor(SUC_Uitval)) |> 
  
  ## Herorden de levels van de variabele studiekeuzeprofiel
  mutate(VOP_Studiekeuzeprofiel_LTA_afkorting = fct_relevel(
    VOP_Studiekeuzeprofiel_LTA_afkorting,
    lLevels_skp
  )) |> 
  
  ## Herorden de levels van de variabele aansluiting
  mutate(INS_Aansluiting_LTA = fct_relevel(
    INS_Aansluiting_LTA,
    lLevels_aansluiting
  )) |>
  
  ## Herorden de levels van de variabele vooropleiding
  mutate(VOP_Toelaatgevende_vooropleiding_soort = fct_relevel(
    VOP_Toelaatgevende_vooropleiding_soort,
    lLevels_vop
  ))
  
```

## Selecteer en inspecteer de data

We selecteren eerst de relevante variabelen. We verwijderen daarbij variabelen die maar 1 waarde hebben. We bekijken de variabelen in een samenvatting in relatie tot de Uitval. Daarnaast bekijken we de kwaliteit van de data op missende waarden.

```{r}

## Maak een subset
dfOpleiding_inschrijvingen <- dfOpleiding_inschrijvingen_base |>
  select(
    INS_Student_UUID_opleiding_vorm,
    DEM_Geslacht,
    DEM_Leeftijd_1_oktober,
    GIS_Tijd_fiets_OV,
    INS_Aantal_inschrijvingen,
    INS_Collegejaar,
    INS_Dagen_tussen_aanmelding_en_1_september,
    INS_Aansluiting_LTA,
    INS_Navitas_tf,
    SES_Totaalscore,
    SUC_Uitval,
    VOP_Gemiddeld_eindcijfer_VO_van_de_hoogste_vooropleiding_voor_het_HO,
    VOP_Studiekeuzeprofiel_LTA_afkorting,
    VOP_Toelaatgevende_vooropleiding_soort
  ) |>
  
  ## Hernoem variabelen voor beter leesbare namen
  rename(
    ID                 = INS_Student_UUID_opleiding_vorm,
    Geslacht           = DEM_Geslacht,
    Leeftijd           = DEM_Leeftijd_1_oktober,
    Reistijd           = GIS_Tijd_fiets_OV,
    Dubbele_studie     = INS_Aantal_inschrijvingen,
    Collegejaar        = INS_Collegejaar,
    Aanmelding         = INS_Dagen_tussen_aanmelding_en_1_september,
    Aansluiting        = INS_Aansluiting_LTA,
    Navitas            = INS_Navitas_tf,
    SES_Totaal         = SES_Totaalscore,
    Uitval             = SUC_Uitval,
    Eindcijfer_VO      = VOP_Gemiddeld_eindcijfer_VO_van_de_hoogste_vooropleiding_voor_het_HO,
    Studiekeuzeprofiel = VOP_Studiekeuzeprofiel_LTA_afkorting,
    Vooropleiding      = VOP_Toelaatgevende_vooropleiding_soort
  ) |> 
  
  ## Verwijder variabelen, waarbij er maar 1 waarde is
  select(where(~ n_distinct(.) > 1)) |>
  
  arrange(Collegejaar, ID)

## Verwijder de basis dataset
rm(dfOpleiding_inschrijvingen_base)

## Maak een samenvatting van de data
dfSummary <- dfOpleiding_inschrijvingen |>
  
  ## Verwijder kolommen die niet relevant zijn voor de analyse
  select(-c(ID, Collegejaar)) |> 
  
  ## Pas de labels van Uitval aan van True naar Ja, en van False naar Nee
  mutate(Uitval = fct_recode(Uitval, "Nee" = "FALSE", "Ja" = "TRUE", )) |>
  
  ## Pas de volgorde van de labels van Uitval aan
  mutate(Uitval = fct_relevel(Uitval, "Ja", "Nee")) |>
  
  ## Bouw de samenvatting op op basis van Uitval
  tbl_summary(
    by = Uitval,
    statistic = list(
      all_continuous() ~ "{mean} ({sd})",
      all_categorical() ~ "{n} / {N} ({p}%)"
    ),
    digits = all_continuous() ~ 2,
    missing = "no"
  ) |> 
  
  ## Richt de vormgeving van de table in
  modify_header(all_stat_cols() ~ "**{level}**, N={n} ({style_percent(p)}%)") |> 
  add_p(pvalue_fun = ~ style_pvalue(.x, digits = 2),
        test.args = all_tests("fisher.test") ~ list(simulate.p.value = TRUE)) |> 
  add_overall(last = TRUE, col_label = "**Totaal**, N = {N}") |> 
  add_n()  |> 
  modify_header(label = "**Variabele**") |> 
  modify_spanning_header(c("stat_1", "stat_2") ~ "**Uitval**") |> 
  bold_labels() 

dfSummary

```

```{r}

## Toon een samenvatting van de data, gesorteerd op missende waarden
diagnose(dfOpleiding_inschrijvingen) |> 
  mutate(missing_percent = round(missing_percent, 2),
         unique_rate = round(missing_percent, 2)) |>
  arrange(desc(missing_percent)) |>
  knitr::kable()

```

## Bewerk de data

-   Uit de eerste diagnose blijkt dat niet alle variabelen goed genoeg zijn voor het bouwen van een prognosemodel: er zijn missende waarden en niet alle veldtypes zijn geschikt. We passen de variabelen aan zodat we in het model er goed mee kunnen werken.
-   Prognosemodellen kunnen niet omgaan met missende waarden. Om bias te voorkomen verwijderen we geen rijen met missende waarden, maar vullen die op (*imputatie*). We bewerken de data zo dat alle missende waarden worden opgevuld: bij numerieke waarden met het gemiddelde en bij categorische variabelen met 'Onbekend'.
-   We passen sommige variabelen aan, zodat ze in het model gebruikt kunnen worden: tekstvelden zetten we om naar factor; logische variabelen (Ja/Nee) zetten we om naar een numerieke variabele (1/0).
-   De uitkomstvariabele, `Uitval`, leiden we af van de variabele `SUC_Uitval_aantal_jaar_LTA`. Als de waarde daar 1 is, is de student na 1 jaar uitgevallen, 2 na 2 jaar, etc.
-   Een fictief studentnummer (`INS_Student_UUID_opleiding_vorm`) gebruiken we ook, zodat we - als er afwijkende resultaten zijn - de dataset gericht kunnen onderzoeken indien nodig.

```{r}
## Bewerk de data
dfOpleiding_inschrijvingen <- dfOpleiding_inschrijvingen |> 
  
  ## Imputeer alle numerieke variabelen met de mean
  mutate(across(where(is.numeric), ~ ifelse(
    is.na(.x),
    mean(.x, na.rm = T),
    .x
  )) ) |>
  
  ## Zet character variabelen om naar factor
  mutate(across(where(is.character), as.factor)) |> 
  
  ## Zet logische variabelen om naar 0 of 1
  mutate(across(where(is.logical), as.integer)) |>
  
  ## Vul in factoren missende waarden op met "Onbekend"
  mutate(across(where(is.factor), ~ suppressWarnings(
    fct_explicit_na(.x, na_level = "Onbekend")
  ))) |> 
  
  ## Herschik de kolommen, zodat Uitval vooraan staat
  select(Uitval, everything()) 
  
## Bekijk de data
glimpse(dfOpleiding_inschrijvingen) 

## Maak een diagnose van de data
diagnose(dfOpleiding_inschrijvingen) |> 
  mutate(missing_percent = round(missing_percent, 2),
         unique_rate = round(missing_percent, 2)) |>
  knitr::kable()

```

## Bouw de trainingset, testset en validatieset

-   De data is nu geschikt om een prognosemodel mee te bouwen.
-   Om het model te bouwen, testen en valideren, splitsen we de data in drie delen van 60%, 20% en 20%. We doen dit op zo'n manier, dat elk deel ongeveer een gelijk aantal studenten bevat dat uitvalt.
-   We trainen het model op basis van 60% en testen de modellen tijden het trainen op de overige 20% (de testset).
-   Als het model klaar is, valideren we het op de 20% studenten uit de validatieset, die is opgebouwd uit zo recent mogelijke data. De validatieset blijft dus de gehele tijd ongemoeid, zodat we overfitting - een te goed model op bekende data, maar slechte performance op onbekende data - voorkomen.
-   Een willekeurig, maar vaststaand seedgetal voorkomt dat we bij elke run van het model c.q. deze code een net iets andere uitkomst krijgen.

```{r}
set.seed(0821)

## Splits de data in 3 delen: 60%, 20% en 20%
splits      <- initial_validation_split(dfOpleiding_inschrijvingen,
                                        strata = Uitval,
                                        prop = c(0.6, 0.2))

## Maak drie sets: een trainingset, een testset en een validatieset
dfUitval_train      <- training(splits)
dfUitval_test       <- testing(splits)
dfUitval_validation <- validation_set(splits)

## Training set proporties uitval
dfUitval_train |> 
  count(Uitval) |> 
  mutate(prop = n/sum(n)) |> 
  knitr::kable()

## Test set proporties uitval
dfUitval_test  |> 
  count(Uitval) |> 
  mutate(prop = n/sum(n)) |> 
  knitr::kable()

```


