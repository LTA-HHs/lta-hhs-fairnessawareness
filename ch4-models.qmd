---
title: "Prognosemodel {{< meta params.model >}}"
subtitle: "`r params$faculteit` | `r params$opleidingsnaam` (`r params$opleiding`) - `r params$opleidingsvorm` - versie `r params$versie`"

# Format and output
output-file: "ch4-models.html"

# Parameters
params:
  versie: "1.0"
  succes: "Retentie na 1 jaar"
  model: "Retentie na 1 jaar"
  propedeusediploma: "Nvt"
  use_synthetic_data: true
  recreateplots: false

  faculteit: "ITD"
  opleidingsnaam: "B Communication and Multimedia Design"
  opleiding: "CMD"
  opleidingsvorm: "voltijd"
  opleidingsvorm_afkorting: "VT"
  instroomselectie: false

# Content
includes:
  inleiding:      true
  model_lr:       true
  model_rf:       true
  model_svm:      false
  final_fit:      true
  conclusions:    true
  contact:        true
  justification:  true
  copyright:      true
---

<!-- Title -->

```{r setup}
#| label: setup
#| include: false

prognose_titel <- paste("Prognosemodel", tolower(params$model)) ## Set the title

source("_Setup.R") # Include the _Setup.R file

bInclude_Model_LR    <- rmarkdown::metadata$includes$model_lr    # Penalized Logistic Regression
bInclude_Model_RF    <- rmarkdown::metadata$includes$model_rf    # Random Forest
bInclude_Model_SVM   <- rmarkdown::metadata$includes$model_svm   # Support Vector Machine
bInclude_Final_fit   <- rmarkdown::metadata$includes$final_fit   # Final Fit
bInclude_Conclusies  <- rmarkdown::metadata$includes$conclusions # Conclusies

dfModel_results <- data.frame(
  model = character(),
  auc = numeric()
)
```

<!-- Methods -->

## Methode, data en analyse

### Toelichting op de methode

Voor de ontwikkeling van prognosemodellen gebruiken we de aanpak van [Tidymodels](https://www.tidymodels.org/). Tidymodels is een framework voor het bouwen van een prognosemodel. Hiermee verzekeren we ons van een systematische, herhaalbare en schaalbare aanpak. De code in deze pagina wordt getoond als deze hoort bij de ontwikkeling van een model. Overige code, voor bijvoorbeeld algemene tabellen of grafieken, kan zichtbaar gemaakt worden.

### Toelichting op de data

De basis voor deze analyse is studiedata van De Haagse Hogeschool (De HHs), verrijkt door het lectoraat LTA. De data bevat informatie over de inschrijvingen van studenten in het eerste jaar van de opleiding:

1.  *Demografische kenmerken*: geslacht, leeftijd, reistijd en SES totaalscore.
2.  *Vooropleidingskenmerken*: toelaatgevende vooropleiding, studiekeuzeprofiel en gemiddeld eindcijfer in de vooropleiding.
3.  *Aanmeldingskenmerken*: aansluiting (direct na diploma, tussenjaar, switch), dag van aanmelding, aantal parallelle studies aan De HHs en collegejaar.

De variabelen die we hebben geselecteerd voor analyse is op basis van standaardgegevens van een popoluatie (leeftijd en geslacht), eerdere analsyes op voorspelkracht voor `r tolower(params$succes)` [@Bakker.2022], of omdat een kenmerk volgens Europese normen geldt als een sensitief kenmerk voor discriminatie [@handboek.2018].

```{r}
#| label: tbl-data-dictionary
#| tbl-cap: "Variabelen en mogelijke waarden"

# Read the data dictionary
dfData_dictionary <- Get_Data_Dictionary()

# Show the data dictionary
Get_tblData_Dictionary(dfData_dictionary)
  

```

### Toelichting op de analyse

We toetsen in deze analyse *`r sSucces_model_text`*, voortaan **Retentie** genoemd.

-   Retentie is gedefinieerd als ingeschreven staan in dezelfde opleiding in een aansluitend collegejaar. Een wisseling van opleidingsvorm binnen de opleiding, bijvoorbeeld van voltijd in jaar 1 naar duaal in jaar 2, geldt ook als retentie. 
-   Uitval is het tegenovergestelde van retentie: niet ingeschreven staan in dezelfde opleiding in een aansluitend collegejaar. 
-   Een wisseling van opleidingsvorm binnen de opleiding, bijvoorbeeld van voltijd in jaar 1 naar duaal in jaar 2, geldt *niet* als uitval.

<!-- Data -->

## Voorbereidingen

### Laad de data

We laden een subset in van historische data specifiek voor:

**Opleiding**: `r params$faculteit` \| `r Get_Opleidingsnaam_Synth(params$opleidingsnaam)` (`r params$opleiding`), `r params$opleidingsvorm`, eerstejaars - **`r sSucces_model`**

```{r}
#| label: load-data

# Read the data for this study progamme
if(params$use_synthetic_data) {
  dfOpleiding_inschrijvingen_base <- Get_Studyprogram_Enrollments_Synthetic(
    studytrack = params$opleiding,
    studyform = toupper(params$opleidingsvorm_afkorting)) |> 
    mutate(
      ID = as.character(ID),
      INS_Opleiding = as.character(INS_Opleiding),
      INS_Opleidingsvorm = as.character(INS_Opleidingsvorm)
    ) |> 
    mutate(
      INS_Student_UUID_opleiding_vorm = paste(ID, INS_Opleiding, INS_Opleidingsvorm, sep = "_"),
      INS_Opleidingsnaam_huidig = paste(INS_Opleidingsnaam_huidig, "(Synth.)", sep = " ")
    )
} else {
  dfOpleiding_inschrijvingen_base <- get_lta_studyprogram_enrollments_pin(
    board = "HHs/Inschrijvingen",
    faculty = params$faculteit,
    studyprogram = params$opleidingsnaam,
    studytrack = params$opleiding,
    studyform = toupper(params$opleidingsvorm),
    range = "eerstejaars")
}

# Adjust dfOpleiding_inschrijvingen_base
dfOpleiding_inschrijvingen_base <- dfOpleiding_inschrijvingen_base |> 
  
  # Rearrange the levels
  mutate(across(all_of(names(lLevels_formal)), ~ factor(.x, 
                                                   levels = lLevels_formal[[cur_column()]]))) |> 

  # Create a simple success variable
  Mutate_Retentie(sSucces_model) |>
  
  # Convert the success variable into a factor
  mutate(SUC_Retentie = as.factor(SUC_Retentie)) |> 

  ## Special possibly based on the propaedeutic diploma
  # Filter_Propedeusediploma(sPropedeusediploma) |>

  # Make the Dual Study variable a Yes/No variable
  Mutate_Dubbele_studie() |>  

  # Remove INS_Aantal_inschrijvingen
  select(-INS_Aantal_inschrijvingen) 

  ## Adjust the levels of sensitive variables
  for(i in lSentitive_formal_variables){
    dfOpleiding_inschrijvingen_base <- dfOpleiding_inschrijvingen_base |>
      Mutate_Levels(
        i,
        list(lLevels_formal[[i]])
      )
  }
  
# B Huidtherapie: Filter on only students with a grade number (selection)
if(opleiding == "HDT") {
  dfOpleiding_inschrijvingen_base <- dfOpleiding_inschrijvingen_base |> 
    filter(!is.na(RNK_Rangnummer)) 
} 

```

### Selecteer en inspecteer de data

We selecteren eerst de relevante variabelen. We verwijderen daarbij variabelen die maar één waarde hebben, omdat die geen voorspellende waarde kunnen hebben. 

```{r}
#| label: select-inspect-data

lSelect <- Get_lSelect(dfVariables, "VAR_Formal_variable")

# B Huidtherapie: add the variable RNK_Rangnummer unless it is HDT
if(opleiding == "HDT") {
  lSelect <- c(lSelect, "RNK_Rangnummer")
}

# Create a mapping with formal and simple maes
lName_mapping <- setNames(dfVariables$VAR_Simple_variable, dfVariables$VAR_Formal_variable)

# Create a subset
dfOpleiding_inschrijvingen <- dfOpleiding_inschrijvingen_base |>
  
  # Select the relevant variables
  select(all_of(lSelect)) |>
  
  # Rename variables for more readable names
  rename_with(~ lName_mapping[.x], .cols = everything()) |> 
  
  # Adjust CBS_APCG_tf to a factor
  Mutate_APCG() |>

  # Indicate where missing numbers are in VO
  Mutate_Cijfers_VO() |>
  
  # Remove variables, where there is only 1 value
  select(where(~ n_distinct(.) > 1)) |>
  
  # Sort
  arrange(Collegejaar, ID)

dfOpleiding_inschrijvingen <- dfOpleiding_inschrijvingen |> 
 ltabase::sort_distinct()

## Remove the base dataset
#rm(dfOpleiding_inschrijvingen_base)

```

We inspecteren de variabelen in een samenvatting in relatie tot retentie en corrigeren daarbij voor multiple testing; de gecorrigeerde significantie-waarden staan vermeld als *q-value*. 

```{r}
#| label: tbl-summary-data
#| tbl-cap: !expr 'glue("Variabelen in relatie tot de uitkomstmaat: {params$succes}")'
#| results: asis

# Create a summary of the data
dfSummary <- dfOpleiding_inschrijvingen |>
  
  # Remove columns not relevant to the analysis
  select(-c(ID, Collegejaar)) |> 
  
  # Adjust the labels of Retention from True to Ja, and from False to Nee
  mutate(Retentie = fct_recode(Retentie, "Nee" = "FALSE", "Ja" = "TRUE")) |>
  
  # Adjust the order of the labels of Retentie
  mutate(Retentie = fct_relevel(Retentie, "Ja", "Nee")) |> 
  
  # Adjust Studiekeuzeprofiel: if NA, then unknown
  mutate(Studiekeuzeprofiel = coalesce(Studiekeuzeprofiel, "Onbekend")) |> 
  
  # Factor all character variables
  mutate(across(where(is.character), as.factor))

# Create a tbl_df of the summary
tbl_dfSummary <- Get_tblSummary(dfSummary) 

tbl_dfSummary
  
```

Daarnaast inspecteren we de kwaliteit van de data op missende waarden.

```{r}
#| label: tbl-summarizy-missing-before
#| tbl-cap: "Kwaliteit van de data voor bewerkingen (gesorteerd op missende waarden)"

# Load dlookr (temporary to avoid conflicts)
suppressMessages(library(dlookr))

# Show a summary of the data, sorted by missing values
diagnose(dfOpleiding_inschrijvingen) |> 
  mutate(missing_percent = round(missing_percent, 2),
         unique_rate = round(missing_percent, 2)) |>
  arrange(desc(missing_percent)) |>
  knitr::kable(col.names = c("Variabelen",
                           "Type",
                           "# Missende waarden",
                           "% Missende waarden",
                           "# Unieke waarden",
                           "Ratio unieke waarden"))

# Detach dlookr
detach("package:dlookr", unload = TRUE)

```

### Bewerk de data

-   Uit de eerste diagnose blijkt dat niet alle variabelen goed genoeg zijn voor het bouwen van een prognosemodel: er zijn missende waarden en niet alle veldtypes zijn geschikt.
-   Om bias te voorkomen verwijderen we geen rijen met missende waarden, maar vullen die op (*imputatie*). We bewerken de data zo dat alle missende waarden worden opgevuld: bij numerieke waarden met het gemiddelde en bij categorische variabelen met 'Onbekend'.
-   We passen het type van sommige variabelen aan, zodat ze in het model gebruikt kunnen worden: tekstvelden zetten we om naar factor (een categorische variabele); logische variabelen (Ja/Nee) zetten we om naar een numerieke variabele (1/0).
-   De uitkomstvariabele, `Retentie`, leiden we af van de variabele `SUC_Uitval_aantal_jaar_LTA`. Als de waarde daar 1 is, is de student na 1 jaar uitgevallen, 2 na 2 jaar, etc. Zolang de waarde daar 0 is, is de student niet uitgevallen.
-   Een fictief studentnummer (`INS_Student_UUID_opleiding_vorm`) gebruiken we, zodat we -- als er afwijkende resultaten zijn -- de dataset gericht kunnen onderzoeken als dat nodig is.

```{r}
#| label: tbl-summarizy-missing-after
#| tbl-cap: "Kwaliteit van de data na bewerkingen (gesorteerd op missende waarden)"

# Edit the data
dfOpleiding_inschrijvingen <- dfOpleiding_inschrijvingen |> 
  
  # Imputate all numeric variables with the mean
  mutate(across(where(is.numeric), ~ ifelse(
    is.na(.x),
    mean(.x, na.rm = T),
    .x
  )) ) |>
  
  # Convert character variables to factor
  mutate(across(where(is.character), as.factor)) |> 
  
  # Convert logical variables to 0 or 1
  mutate(across(where(is.logical), as.integer)) |>
  
  # Fill in factors missing values with “Unknown”
  mutate(across(where(is.factor), ~ suppressWarnings(
    fct_explicit_na(.x, na_level = "Onbekend")
  ))) |> 
  
  # Rearrange the columns so that Retentie is in front
  select(Retentie, everything()) 

## View the data
# glimpse(dfOpleiding_inschrijvingen) 

# Load dlookr (temporary to avoid conflicts)
suppressMessages(library(dlookr))

# Diagnose the data
diagnose(dfOpleiding_inschrijvingen) |> 
  mutate(missing_percent = round(missing_percent, 2),
         unique_rate = round(unique_rate, 2)) |>
  knitr::kable(col.names = c("Variabelen",
                           "Type",
                           "# Missende waarden",
                           "% Missende waarden",
                           "# Unieke waarden",
                           "Ratio unieke waarden"))

# Detach dlookr
detach("package:dlookr", unload = TRUE)

```

### Inspecteer de onderlinge correlaties

Het is verstandig om voorafgaand aan het bouwen van een model te kijken naar de onderlinge correlaties tussen numerieke variabelen. Dit geeft inzicht in de data en kan helpen bij het maken van keuzes voor het model of de duiding van de uitkomsten.

We selecteren uitsluitend numerieke waarden en variabelen die een standaard deviatie hebben die groter is dan 0. We clusteren de data op basis van 4 clusters. De correlatie van de diagonaal verbergen we, aangezien deze altijd 1 is.

Clusters in correlaties kunnen per opleiding verschillen. Onderzoek in de correlaties hoe sterk deze zijn, welke clusters gevormd worden en of deze -- vanuit de context van de opleiding, faculteit of onderwijsinstelling -- logisch zijn. Verwerk de inzichten eventueel in een oplegger. Gangbare clusters zijn:

-   Cijfers: Een correlatie tussen Cijfer SO en Cijfer VO: dit geeft aan dat het schoolexamen hetzelfde meet als het centraal examen. Exacte vakken en talen kunnen met elkaar correleren.
-   Reistijd en SES: Deze zijn gecorreleerd aangezien SES scores zijn afgeleid van wijken. Wijken hebben een specifieke reistijd en positionering ten opzichte van de vestigingslocaties van De HHs kennen.
-   Leeftijd is vaak niet gecorreleerd met andere variabelen.

```{r}
#| label: fig-corplot-data
#| fig-cap: "Correlatiematrix"

# Create a plot of the intercorrelations in numerical variables
# Remove columns with a standard deviation of 0
dfCorrelation <- dfOpleiding_inschrijvingen |> 
  select(-Collegejaar) |>
  select(where(is.numeric)) |> 
  select_if(~ sd(.) != 0) |>
  cor()

dfCorrelation |>  
corrplot::corrplot(
  order = 'hclust', 
  addrect = 4,
  method = "number",
  hclust.method = "complete",
  tl.cex = 0.8,       
  tl.col = "black",
  diag = FALSE)

```

```{r}
#| label: fig-corplot-dendrogram
#| fig-cap: "Dendrogram van de correlatiematrix"

# Apply hierarchical clustering
dist   <- as.dist(1 - dfCorrelation)      # Create a distance matrix
hclust <- hclust(dist, method = "complete")  # Hierarchical clustering

# Plot the dendrogram
# plot(hclust, cex = 0.8)

# Create a clustering
dfClusters <- cutree(hclust, k = 4)

# Show clustering
# dfClusters

```

### Bouw de trainingset, validatieset en testset

-   De data is nu geschikt om een prognosemodel mee te bouwen.
-   Om het model te bouwen, testen en valideren, splitsen we de data in drie delen van 60%, 20% en 20%. We doen dit op zo'n manier, dat elk deel ongeveer een gelijk aantal studenten bevat dat doorstudeert (dus niet uitvalt).
-   We trainen het model op basis van 60% en valideren de modellen tijdens het trainen op de overige 20% (de validatieset).
-   De verdeling van de training- en validatieset muteren we 10x (10 *folds*) om te voorkomen dat het model te veel leert van de trainingset en daardoor slecht presteert op de validatieset.
-   Als het model klaar is, testen we het op de 20% studenten uit de testset. De testset blijft dus de gehele tijd ongemoeid, zodat we overfitting - een te goed model op bekende data, maar slechte presetaties (*performance*) op onbekende data - voorkomen.
-   Een willekeurig, maar vaststaand *seed*-getal voorkomt dat we bij elke run van het model c.q. deze code een net iets andere uitkomst krijgen.

We ontwikkelen in de verdere analyse eerst een aantal modellen en testen de prestaties daarvan op de trainingset en validiatieset. Vervolgens bepalen we welk model het beste presteert en passen dat model dan toe op de testset (de uiteindelijke fit). Vandaar dat het toetsen van de prestaties van de modellen meerdere keren behandeld wordt.

```{r}
#| label: fig-dataset-split
#| fig-cap: "Splitsing van de dataset in trainingset, validatieset en testset"
#| out-width: 80%
knitr::include_graphics(here::here("R/images", "prognosemodel-dataset-lta-hhs.png"))
```


```{r}
#| label: split-data

set.seed(0821)

# Split the data into 3 parts: 60%, 20% and 20%
splits      <- initial_validation_split(dfOpleiding_inschrijvingen,
                                        strata = Retentie,
                                        prop = c(0.6, 0.2))

# Create three sets: a training set, a test set and a validation set
dfRetentie_train      <- training(splits)
dfRetentie_test       <- testing(splits)
dfRetentie_validation <- validation_set(splits)

# Create a resample set based on 10 folds (default)
dfRetentie_resamples  <- vfold_cv(dfRetentie_train, strata = Retentie)
```

```{r}
#| label: tbl-split-data
#| tbl-cap: "Verhouding van de uitkomstvariabele in de training- en testset"
#| echo: false

# Training set proportions
dfRetentie_train_prop <- dfRetentie_train |> 
  count(Retentie) |> 
  mutate(Naam = "Trainingset",
         prop = n/sum(n)) 

# Test set proportions
dfRetentie_test_prop <- dfRetentie_test  |> 
  count(Retentie) |> 
  mutate(Naam = "Testset",
         prop = n/sum(n)) 

# Combine the training and test set to display in a table
bind_rows(dfRetentie_train_prop,
          dfRetentie_test_prop) |> 
  mutate(prop = scales::percent(prop, accuracy = 0.1)) |>
  select(Naam, Retentie, n, prop) |> 
  knitr::kable(col.names = c("Naam", "Retentie", "Aantal", "Proportie"))

```

<!-- MODEL I: Penalized Logistic Regression -->

::: {.content-hidden unless-meta="includes.model_lr"}
## Model I: Logistische Regressie

-   Het eerste model is een [logistische regressie met penalized likelihood](https://wikistatistiek.amc.nl/Logistische_regressie); we gebruiken de `glmnet` engine voor het bouwen van het model. Penalized likelihood is een techniek die helpt bij het voorkomen van overfitting: het voegt voor elke extra variabele een strafterm toe om eenvoudige modellen te belonen. [Glmnet](https://glmnet.stanford.edu/articles/glmnet.html) is een veelgebruikt package voor het bouwen van logistische regressiemodellen.
-   We gebruiken de [Area under the ROC Curve (AUC/ROC)](https://nl.wikipedia.org/wiki/ROC-curve) als performance metric. De ROC-curve (Receiver Operating Characteristic) is een grafiek die de prestaties van een classificatiemodel afbeeldt door de verhouding tussen de *true positives* (sensitiviteit) en de *false positives* (aspecficiteit = 1-specificiteit) te plotten bij verschillende drempelwaarden. De oppervlakte onder deze curve, bekend als de AUC (Area Under the Curve), kwantificeert het onderscheidingsvermogen van het model; een AUC van 1 duidt op een perfect onderscheidend vermogen, terwijl een AUC van 0,5 wijst op een model zonder onderscheidend vermogen.

### Maak het model

Eerst bouwen we het model.

```{r}
#| label: lr-mod
#| code-fold: false

# Build the model: logistic regression
lr_mod <- 
  logistic_reg(penalty = tune(), mixture = 1) |> 
  set_engine("glmnet")
```

### Maak de recipe

Vervolgens zetten we meerdere stappen in een 'recipe':

-   We definiëren de student-ID als ID variabele. Daarmee krijgt deze variabele de rol van uniek rij-kenmerk.
-   We verwijderen vervolgens de oorspronkelijke student-ID en het collegejaar uit de data, omdat deze verder niet gebruikt moeten worden in het model.
-   We converteren factoren naar dummy variabelen: voor elke categorie wordt er een nieuwe logische variabele (Ja/Nee) aangemaakt.
-   We verwijderen variabelen die geen waarde toevoegen: variabelen met uitsluitend nullen.
-   We normaliseren numerieke variabelen om ze met elkaar te kunnen vergelijken door ze te centreren en schalen: het transformeert numerieke gegevens zodat ze een standaard deviatie van één en een gemiddelde van nul hebben.
-   Sterk gecorreleerde waarden verwijderen we nu niet, omdat we later in de analyse de eventuele samenhang met andere variabelen in een prognosemodel nog willen kunnen visualiseren.

```{r}
#| label: lr-recipe
#| code-fold: false

# Build the recipe: logistic regression
lr_recipe <- 
  recipe(Retentie ~ ., data = dfRetentie_train) |>  
  update_role(ID, new_role = "ID") |>           # Set the student ID as an ID variable
  step_rm(ID, Collegejaar) |>                   # Remove ID and college year from the model
  step_unknown(Studiekeuzeprofiel, 
               new_level = "Onbekend skp") |>   # Add unknown skp
  step_dummy(all_nominal_predictors()) |>       # Create dummy variables from categorical variables
  step_zv(all_predictors()) |>                  # Remove zero values
  step_normalize(all_numeric_predictors())      # Center and scale numeric variables

```

```{r}
#| label: tbl-lr-recipe-steps
#| tbl-cap: "Recipesteps voor logistische regressie"

# Show the recipe
tidy(lr_recipe) |> 
  knitr::kable(col.names = c("Nummer", 
                             "Operatie", 
                             "Type",
                             "Getraind",
                             "Sla over",
                             "ID"))
```

De variabelen die nu nog overblijven zijn:

```{r}
#| label: tbl-lr-recipe-final
#| tbl-cap: "Resterende variabelen voor logistische regressie na bewerkingen"
#| echo: false

# Show the variables remaining
model_vars <- lr_recipe |> 
  prep() |> 
  juice() |> 
  names()

# Add empty values to make the length divisible by 3
while (length(model_vars) %% 3 != 0) {
  model_vars <- c(model_vars, "")
}

model_vars_matrix <- matrix(model_vars, ncol = 3, byrow = FALSE)

knitr::kable(model_vars_matrix)

```

### Maak de workflow

Voor de uitvoering bouwen we een workflow. Daaraan voegen we het model en de bewerkingen in de recipe toe.

```{r}
#| label: lr-workflow
#| code-fold: false

# Create the workflow: logistic regression
lr_workflow <- 
  workflow() |>         # Create a workflow
  add_model(lr_mod) |>  # Add the model
  add_recipe(lr_recipe) # Add the recipe

# Show workflow
lr_workflow
```

### Tune en train het model

Het model moet getuned worden. Dit houdt in dat we de beste parameters voor het model moeten vinden. We maken een grid met verschillende penalty waarden. Daarmee kunnen we vervolgens het beste model selecteren met de hoogste ROC/AUC. We plotten de resultaten van de tuning, zodat we hieruit het beste model kunnen kiezen.

```{r}
#| label: lr-reg-grid
#| code-fold: false

# Create a grid: logistic regression
lr_reg_grid <- tibble(penalty = 10 ^ seq(-4, -1, length.out = 30))

# Train and tune the model: logistic regression
lr_res <- 
  lr_workflow |> 
  tune_grid(dfRetentie_validation,
            grid = lr_reg_grid,
            control = control_grid(save_pred = TRUE),
            metrics = metric_set(roc_auc))

```

```{r}
#| label: fig-lr-plot
#| fig-cap: "Tuning resultaten logistische regressie"

# Plot the results + a red vertical line for the max AUC
lr_plot <- 
  lr_res |> 
  collect_metrics() |> 
  ggplot(aes(x = penalty, y = mean)) + 
  geom_point() + 
  geom_line() + 
  
  # Make the scale of the x-axis logarithmic
  scale_x_log10(labels = scales::label_number()) +
    theme(
      axis.title.x = element_text(margin = margin(t = 20))
    ) +
  
  # Define the title, subtitle and caption
  labs(
    caption = sCaption,
    x = "Area under the ROC Curve",
    y = "Penalty"
  )
  
  # Add theme elements
  lr_plot <- Add_Theme_Elements(lr_plot, title_subtitle = FALSE)
  
# Find the penalty value with the max AUC
max_auc_penalty <- lr_res |> 
  collect_metrics() |> 
  filter(mean == max(mean)) |> 
  pull(penalty)

# Add the red vertical line to lr_plot
lr_plot_plus <- lr_plot + 
  geom_vline(xintercept = max_auc_penalty, color = "red")

# Find a mean for the max AUC that is higher
max_auc_mean <- lr_res |> 
  collect_metrics() |> 
  filter(mean == max(mean)) |> 
  pull(penalty)

# Print the final plot
lr_plot_plus

```

### Kies het beste model

De prestaties van een model gevisualiseerd met behulp van een ROC curve. De sensitiviteit (True Positive Rate) en specificiteit (True Negative Rate) worden hierin tegenover elkaar uitgezet. De Area under the ROC Curve (AUC/ROC) geeft de prestaties van het model weer. Het model scoort beter naarmate de AUC/ROC dichter bij de 1 ligt, de linker bovenhoek. De linker bovenhoek houdt in dat alle prognoses exact overeenstemmen met de werkelijkheid. Een AUC/ROC van 0,5 betekent dat het model niet beter presteert dan een willekeurige voorspelling.

We gebruiken modellen met een zo hoog mogelijke Area under the ROC Curve (AUC/ROC) en een zo laag mogelijke penalty. Zo kunnen we uit de resultaten het beste model kiezen en visualiseren.

```{r}
#| label: lr-top-models
#| code-fold: false

# Show the best model
top_models <-
  lr_res |> 
  show_best(metric = "roc_auc", n = 10) |> 
  mutate(mean = round(mean, 6)) |>
  arrange(penalty) 
```

```{r}
#| label: tbl-lr-top-models
#| tbl-cap: "Model performance voor logistische regressie"

top_models|> 
  knitr::kable(col.names = c("Penalty", 
                             "Metriek", 
                             "Estimator",
                             "Gemiddelde",
                             "Aantal",
                             "SE",
                             "Configuratie"))

```

```{r}
#| label: lr-best
#| code-fold: false

# Select the best model: logistic regression
lr_best <- 
  lr_res |> 
  collect_metrics() |> 
  filter(mean == max(mean)) |>
  slice(1) 
```

```{r}
#| label: tbl-lr-best
#| tbl-cap: "Hoogste model performance voor logistische regressie"

lr_best|> 
  mutate(mean = round(mean, 6)) |>
  knitr::kable(col.names = c("Penalty", 
                             "Metriek", 
                             "Estimator",
                             "Gemiddelde",
                             "Aantal",
                             "SE",
                             "Configuratie"))

```

```{r}
#| label: lr-auc
#| code-fold: false

# Collect the predictions and evaluate the model (AUC/ROC): logistic regression
lr_auc <- 
  lr_res |> 
  collect_predictions(parameters = lr_best) |> 
  roc_curve(Retentie, .pred_FALSE) |> 
  mutate(model = "Logistisch Regressie")
```
```{r}
#| label: fig-lrauc
#| fig-cap: "ROC curve voor logistische regressie"

# Plot the ROC curve
Get_ROC_Plot(lr_auc, position = 1)
```

```{r}
#| label: lr-auc-highest

# Determine the AUC of the best model
lr_auc_highest   <-
  lr_res |>
  collect_predictions(parameters = lr_best) |> 
  roc_auc(Retentie, .pred_FALSE)

# Add model name and AUC dfModel_results
dfModel_results <- 
  dfModel_results |>
  add_row(model = "Logistic Regression", auc = lr_auc_highest$.estimate)

```
:::

<!-- MODEL II: Random Forest -->

::: {.content-hidden unless-meta="includes.model_rf"}
## Model II: Tree-based ensemble

-   Het tweede model is een [random forest](https://en.wikipedia.org/wiki/Random_forest): een ensemble van beslisbomen (*decision trees*). Het is een krachtig model dat goed om kan gaan met complexe data en veel variabelen.
-   We gebruiken de [`ranger` engine](https://cran.r-project.org/web/packages/ranger/index.html) voor het bouwen van het model.

### Bepaal het aantal PC-cores

Omdat een random forest model veel berekeningen vereist, willen we daarvoor alle computerkracht gebruiken die beschikbaar is. Het aantal CPU's (*cores*), wat verschilt per computer, bepaalt hoe snel het model getraind kan worden. We bepalen het aantal cores en gebruiken dat bij het bouwen van het model.

```{r}
#| label: cores

# Determine the number of cores
cores <- parallel::detectCores()

```

### Maak het model

We bouwen eerst het model. We gebruiken de `rand_forest` functie om het model te bouwen. We tunen de `mtry` en `min_n` parameters. De `mtry` parameter bepaalt het aantal variabelen dat per boom wordt gebruikt. De `min_n` parameter bepaalt het minimum aantal observaties dat in een blad van de boom moet zitten. De functie `tune()` is hier nog een *placeholder* om de beste waarden voor deze parameters - die we later bepalen - in te kunnen stellen. We gebruiken 1.000 bomen c.q. versies van het model.

```{r}
#| label: rf-mod
#| code-fold: false

# Build the model: random forest

rf_mod <- 
  rand_forest(mtry = tune(), min_n = tune(), trees = 1000) |> 
  set_engine("ranger", num.threads = cores) |> 
  set_mode("classification")
```

### Maak de recipe

We maken een recipe voor het random forest model. We verwijderen de student ID en het collegejaar uit de data, omdat deze niet moet worden gebruikt in het model. Overige stappen zijn bij een random forest minder relevant in tegenstelling tot een regressiemodel.

```{r}
#| label: rf-recipe
#| code-fold: false

# Create the recipe: random forest
rf_recipe <- 
  recipe(Retentie ~ ., data = dfRetentie_train) |> 
  step_unknown(Studiekeuzeprofiel, 
               new_level = "Onbekend skp") |>   # Add unknown skp
  step_rm(ID, Collegejaar)                      # Remove ID and Collegejaar from the model
```

```{r}
#| label: tbl-rf-recipe
#| tbl-cap: "Recipesteps voor random forest"

# Show the recipe
tidy(rf_recipe) |> 
  knitr::kable(col.names = c("Nummer", 
                             "Operatie", 
                             "Type",
                             "Getraind",
                             "Sla over",
                             "ID"))
```

### Maak de workflow

We voegen het model en de recipe toe aan de workflow voor dit model.

```{r}
#| label: rf-workflow
#| code-fold: false

# Create the workflow: random forest
rf_workflow <- 
  workflow() |> 
  add_model(rf_mod) |> 
  add_recipe(rf_recipe)

# Show workflow
rf_workflow
```

### Tune en train het model

We trainen en tunen het model in de workflow. We maken een grid met verschillende waarden voor de parameters `mtry` en `min_n`. We gebruiken de Area under the ROC Curve (AUC/ROC) als performance metric. Met de resultaten van de tuning kiezen we het beste model.

```{r}
#| label: rf-tune
#| code-fold: false

# Show the parameters that can be tuned
rf_mod

# Extract the parameters being tuned
extract_parameter_set_dials(rf_mod)

# Determine the seed
set.seed(2904)

# Build the grid: random forest
rf_res <- 
  rf_workflow |> 
  tune_grid(dfRetentie_validation,
            grid = 25,
            control = control_grid(save_pred = TRUE),
            metrics = metric_set(roc_auc))
```

### Kies het beste model

We evalueren de beste modellen en maken een ROC curve om de performance van het model te visualiseren. Vervolgens vergelijken we de prestaties van de modellen en kiezen daaruit het beste model.

```{r}
#| label: tbl-rf-results
#| tbl-cap: "Model performance voor random forest"
#| code-fold: false

# Show the best models
rf_res |> 
  show_best(metric = "roc_auc", n = 15) |> 
  mutate(mean = round(mean, 6)) |>
  knitr::kable(col.names = c("Mtry", 
                             "Min. aantal", 
                             "Metriek",
                             "Estimator",
                             "Gemiddelde",
                             "Aantal",
                             "SE",
                             "Configuratie"))

```
```{r}
#| label: fig-rf-results
#| fig-cap: "Model performance random forest"

# Plot the results
autoplot <- autoplot(rf_res) +
  theme_minimal() +
  labs(
    y = "roc/auc",
    caption = sCaption
  )
  
  # Add theme elements
  autoplot <- Add_Theme_Elements(autoplot, title_subtitle = FALSE)
  
  print(autoplot)

```

```{r}
#| label: rf-best
#| code-fold: false

# Select the best model
rf_best <- 
  rf_res |> 
  select_best(metric = "roc_auc")

```

```{r}
#| label: tbl-ref-best
#| tbl-cap: "Hoogste model performance voor random forest"

rf_best|> 
  knitr::kable(col.names = c("Mtry", 
                             "Min. aantal", 
                             "Configuratie"))

```

```{r}
#| label: tbl-rf-predictions
#| tbl-cap: "Predicties voor random forest"

# Collect the predictions
rf_res |> 
  collect_predictions() |> 
  head(10) |>
  mutate(.pred_FALSE = scales::percent(.pred_FALSE, accuracy = 0.1),
         .pred_TRUE = scales::percent(.pred_TRUE, accuracy = 0.1)) |>
  knitr::kable(col.names = c("% Voorsp. FALSE", 
                             "% Voorsp. TRUE", 
                             "ID",
                             "Rij",
                             "Mtry", 
                             "Min. aantal", 
                             "Retentie",
                             "Configuratie"))
```

```{r}
#| label: fig-rf-auc
#| fig-cap: "ROC curve voor random forest"
 
# Determine the AUC/ROC curve
rf_auc <- 
  rf_res |> 
  collect_predictions(parameters = rf_best) |> 
  roc_curve(Retentie, .pred_FALSE) |> 
  mutate(model = "Random Forest")

# Plot the ROC curve
Get_ROC_Plot(rf_auc, position = 2)

# Determine the AUC of the best model
rf_auc_highest   <-
  rf_res |>
  collect_predictions(parameters = rf_best) |> 
  roc_auc(Retentie, .pred_FALSE)

# Add model name and AUC to dfModel_results
dfModel_results <- 
  dfModel_results |>
  add_row(model = "Random Forest", 
          auc = rf_auc_highest$.estimate)

```
:::

<!-- Final Fit -->

## De uiteindelijke fit

-   In de laatste stap van deze analyse maken we het model definitief.
-   We testen het model op de testset en evalueren het model met metrieken en de Variable Importance (VI). De VI kwantificeert de bijdrage van elke variabele aan de voorspellende kracht van een model. Het identificeert welke variabelen significant zijn voor de modelprestaties, wat essentieel is voor het interpreteren en optimaliseren van een model [@VanderLaan.2006]. Methoden zoals de Shapley-waarde en permutation importance worden vaak toegepast om dit belang te meten. Op deze methoden komen we terug in het volgende hoofdstuk.

### Combineer de AUC/ROC curves en kies het beste model

Eerst combineren we de AUC/ROC curves van de modellen om ze te vergelijken. We kiezen het beste model op basis van de hoogste AUC/ROC.

```{r}
#| label: fig-bind-rows-auc-roc
#| fig-cap: "Gecombineerde ROC curves"

# Combine the AUC/ROC curves to compare the models
Get_ROC_Plot(list(lr_auc, rf_auc))

```

```{r}
#| label: best-model-auc-roc

# Determine which of the models is best based on highest AUC/ROC
dfModel_results <- dfModel_results |>
  mutate(number = row_number()) |> 
  mutate(best = ifelse(auc == max(auc), TRUE, FALSE)) |> 
  arrange(number)

# Determine the best model
sBest_model     <- dfModel_results$model[dfModel_results$best == TRUE]
sBest_model_auc <- round(dfModel_results$auc[dfModel_results$best == TRUE], 4)
```

```{r}
#| label: best-model-auc-roc-text
#| echo: false
#| results: asis

# Build the text for the best models
sText_best_model <- dfModel_results |> 
  filter(best == FALSE) |> 
  glue_data("Het {model} model heeft een AUC van {round(auc, 4)}. ") |> 
  stringr::str_flatten()

# Rearrange the final text for a clear summary
sText_best_model <-
  glue(
    "Het beste model is het **{sBest_model}** model met een **AUC/ROC van {sBest_model_auc}**. {sText_best_model} We ronden de analyse verder af met het {sBest_model} model op de validatieset."
  )

```

`r sText_best_model`

### Maak het finale model

```{r}
#| label: text-final-model
#| echo: false
#| results: asis

# Build the text for the final model
if(sBest_model == "Logistisch Regressie") {
  
  # Make the final model
  sText_final_model <- "We maken het finale model op basis van de beste parameters die we hebben gevonden. Voor het Logistisch Regressie model is dit het model met de beste penalty en mixture."

} else if (sBest_model == "Random Forest") {
  
  # Make the final model
  sText_final_model <- "We maken het finale model op basis van de beste parameters die we hebben gevonden. Door in de engine bij `importance` de `impurity` op te geven, wordt het beste random forest model gekozen om de data definitief mee te classificeren."

}
```

We maken het finale model op basis van de beste parameters die we hebben gevonden. Door in de engine bij `importance` de `impurity` op te geven, wordt het beste random forest model gekozen om de data definitief mee te classificeren.

```{r}
#| label: last-mod
#| code-fold: false

# Test the developed model on the test set
# Determine the optimal parameters

# Build the final models
last_lr_mod <-
    logistic_reg(penalty = lr_best$penalty,
                 mixture = 1) |>
    set_engine("glmnet") |>
    set_mode("classification")

last_rf_mod <-
    rand_forest(mtry = rf_best$mtry,
                min_n = rf_best$min_n,
                trees = 1000) |>
    set_engine("ranger", num.threads = cores, importance = "impurity") |>
    set_mode("classification")

```

### Maak de workflow

We voegen het model toe aan de workflow en updaten de workflow met het finale model.

```{r}
#| label: last-workflow
#| code-fold: false

# Update the workflows
 last_lr_workflow <- 
    lr_workflow |> 
    update_model(last_lr_mod)

 last_rf_workflow <- 
    rf_workflow |> 
    update_model(last_rf_mod)

```

### Fit het finale model

We voeren de finale fit uit. De functie `last_fit` past het model toe op de validatieset.

```{r}
#| label: last-fit
#| code-fold: false

# Perform the final fit
set.seed(2904)

# Make a final fit for both models so we can save it for later use
last_fit_lr <- 
    last_lr_workflow |> 
    last_fit(splits)

last_fit_rf <- 
    last_rf_workflow |> 
    last_fit(splits)

lLast_fits <- list(last_fit_lr, last_fit_rf) |> 
  set_names(c("Logistic Regression", "Random Forest"))

# Determine which model is best
if(sBest_model == "Logistic Regression") {
  last_fit <- last_fit_lr
} else if(sBest_model == "Random Forest") {
  last_fit <- last_fit_rf
}

# Keep results, model results and associated data
sFittedmodels_outputpath <- Get_Model_Outputpath(mode = "last-fits")
saveRDS(lLast_fits, file = sFittedmodels_outputpath)

sModelresults_outputpath <- Get_Model_Outputpath(mode = "modelresults")
saveRDS(dfModel_results, file = sModelresults_outputpath)

sData_outputpath <- Get_Model_Outputpath(mode = "data")
saveRDS(dfOpleiding_inschrijvingen, file = sData_outputpath)

```

### Evalueer het finale model: metrieken en variable importance

We evalueren het finale model nu grondiger op basis van 4 metrieken: 1) accuraatheid, 2) ROC/AUC en 3) de [Brier score](https://en.wikipedia.org/wiki/Brier_score) (de Mean Squared Error). Het is zinvol om accuraatheid, ROC/AUC en de Brier-score pas bij het finale model toe te passen, omdat dit efficiënter is en overfitting voorkomt. Zo combineren we een snelle modelselectie met een grondige evaluatie van het uiteindelijke model.

```{r}
#| label: last-fit-metrics-vi
#| code-fold: false

# Collect the metrics
last_fit |> 
  collect_metrics() |> 
  mutate(.estimate = round(.estimate, 4)) |>
  knitr::kable(col.names = c("Metriek", 
                             "Estimator",
                             "Estimate",
                             "Configuratie"))

```

### Plot de ROC curve

Tot slot visualiseren we de prestaties weer met een ROC curve van het beste model.

```{r}
#| label: fig-last-fit-roc
#| fig-cap: "ROC curve finale model"
#| code-fold: false

# Show the roc curve
auc_lf <- last_fit |> 
  collect_predictions() |> 
  roc_curve(Retentie, .pred_FALSE) |> 
  mutate(model = "Last fit")

Get_ROC_Plot(auc_lf, position = 3)

```

<!-- Conclusions -->

## Conclusies

```{r}
#| label: conclusions-accuracy
#| code-fold: false
#| echo: false

# Determine model accuracy, average retention rate and base model
Last_fit_Accuracy   <- last_fit |>
  collect_metrics() |>
  filter(.metric == "accuracy") |>
  pull(.estimate) |>
  round(4) * 100
Avg_Retentie        <- round(mean(dfOpleiding_inschrijvingen$Retentie == TRUE) * 100, 2)
Avg_Non_Retentie    <- round(100 - Avg_Retentie, 2)

if(Avg_Retentie < 50) {
  Base_Model_Accuracy <- round(100 - Avg_Retentie, 2)
  sRetentie <- "die niet doorstudeerde"
} else {
  Base_Model_Accuracy <- Avg_Retentie
  sRetentie <- "die doorstudeerde"
}

# Now calculate the difference in accuracy
nAccuracy_verschil  <- round(abs(Last_fit_Accuracy - Base_Model_Accuracy), 2)
pAccuracy_verschil  <- paste0(nAccuracy_verschil, "%") 

# Features
Get_Accuracy_vergelijking <-
  function(Last_fit_Accuracy, Base_Model_Accuracy) {
    if (Last_fit_Accuracy == Base_Model_Accuracy) {
      "even goed als"
    } else if (Last_fit_Accuracy > Base_Model_Accuracy) {
      "beter"
    } else {
      "slechter"
    }
  }
  
Get_Accuracy_niveau <- function(Last_fit_Accuracy) {
  if (Last_fit_Accuracy > 95) {
    "zeer hoog"
  } else if (Last_fit_Accuracy > 90) {
    "hoog"
  } else if (Last_fit_Accuracy > 80) {
    "vrij hoog"
  } else if (Last_fit_Accuracy > 70) {
    "gemiddeld"
  } else if (Last_fit_Accuracy > 60) {
    "vrij laag"
  } else {
    "laag"
  }
}
  
Get_Accuracy_verschil <- function(nAccuracy_verschil) {
  if (nAccuracy_verschil < 5) {
    "iets"
  } else if (nAccuracy_verschil < 10) {
    "wat"
  } else if (nAccuracy_verschil < 20) {
    "een stuk"
  } else {
    "veel"
  }
}

# Functions to create sentences and print variables
Special_Paste  <- function(vec) sub(",\\s+([^,]+)$", " en \\1", toString(vec))
Print_Variable <- function(variable) paste0("`", variable, "`")

# Determine a number of texts
sAccuracy_vergelijking <- Get_Accuracy_vergelijking(Last_fit_Accuracy, Base_Model_Accuracy)
sAccuracy_niveau       <- Get_Accuracy_niveau(Last_fit_Accuracy)
sAccuracy_verschil     <- Get_Accuracy_verschil(nAccuracy_verschil)

# Determine the top 3 and top 5 variables based on the VI
dfTop_vi   <- last_fit |> 
  extract_fit_parsnip() |> 
  vip::vi() |> 
  arrange(desc(Importance)) 

lTop3_vi <- dfTop_vi |>
  slice(1:3) |>
  pull(Variable) |>
  # Adjust the variables so that they are between backticks
  Print_Variable() |>
  # Make it a sentence
  Special_Paste()  

lTop45_vi <- dfTop_vi |>
  # Lines 4 and 5
  slice(4:5) |>
  pull(Variable) |>
  # Adjust the variables so that they are between backticks
  Print_Variable() |>
  # Make it a sentence
  Special_Paste()

sConclusie_text <- ""

if(!("Eindcijfer_VO" %in% dfTop_vi$Variable[1:3]) 
   & "Eindcijfer_VO" %in% dfTop_vi$Variable[4:5]) {
  sConclusie_text <- glue::glue(
    sConclusie_text,
    "**Het model toont wel aan dat de herkomst van studenten sterker is gecorreleerd met {tolower(sSucces_model)} dan eerdere prestaties of vooropleiding.** ",
    "De _Variable Importance Factor_ (VI) laat namelijk zien dat de variabelen {lTop3_vi} de 3 belangrijkste variabelen zijn voor het voorspellen van {tolower(sUitval_model)}, gevolgd door {lTop45_vi}."
  )
} else if ("Eindcijfer_VO" %in% dfTop_vi$Variable[1:3]) {
  sConclusie_text <- glue::glue(
    sConclusie_text,
    "**Het model toont aan dat eerdere prestaties van studenten sterker zijn gecorreleerd met {tolower(sSucces_model)} dan herkomst.** ",
    "De _Variable Importance_ (VI) laat namelijk zien dat de variabelen {lTop3_vi} de 3 belangrijkste variabelen zijn voor het voorspellen van {tolower(sSucces_model)}, gevolgd door {lTop45_vi}."
  )
} else {
  sConclusie_text <- "**Vooralsnog geen nadere bijzonderheden.**"
}

```

### Het beste prognosemodel voor deze opleiding

**Het beste prognosemodel blijkt het `r sBest_model` model te zijn.**

-   Van de prognosemodellen die we hebben ontwikkeld om `r tolower(sSucces_model)` te voorspellen, had het `r sBest_model` model de hoogste AUC/ROC waarde (`r sBest_model_auc`).

### Mate van accuraatheid en lift

Een prognosemodel moet minimaal beter presteren dan een *base-model* om waarde op basis van accuraatheid toe te voegen. Het base-model neemt als basis de grootste klasse van de gemiddelde `r tolower(sSucces_model)` van de afgelopen jaren. Stel we zouden tegen alle studenten zeggen dat ze hun studie gaan halen, dan is de mate van accuratesse gelijk aan dit base-model. Dit base-model is dus altijd hoger dan de 50% lijn van de AUC/ROC curve, tenzij het base-model toevallig precies 50% is.


```{r}
#| label: fig-basemodel-lift
#| fig-cap: "Lift afhankelijk van base-model en accuraatheid"
#| out-width: 80%

knitr::include_graphics(here::here("R/images", "basemodel-lift.png"))

```

**De mate van accuraatheid van het prognosemodel is `r sAccuracy_niveau` (`r Last_fit_Accuracy`%).**

-   **Base-model: `r Base_Model_Accuracy`%** -- Voor deze opleiding berekenen we het base-model als volgt. Van alle studenten studeerde `r Avg_Retentie`% door; 100% - `r Avg_Retentie`% = `r Avg_Non_Retentie`% studeerde *niet* door. De grootste klasse van deze twee, `r Base_Model_Accuracy`%, is daarmee de accuratesse van het base-model.
-   **Accuratesse prognose: `r Last_fit_Accuracy`%** -- Het model voorspelt `r sSucces_model` met een accuratesse van `r Last_fit_Accuracy`%.
-   **Lift: `r pAccuracy_verschil`** -- Het model scoort in de huidige opbouw met een verschil van `r pAccuracy_verschil` (de *lift*) `r sAccuracy_verschil` `r sAccuracy_vergelijking` dan de accuraatheid van het base-model.

### Confusion Matrix

```{r}
#| label: confusion-matrix-calculation

# Determine the confusion matrix
confusion_matrix <- last_fit |>
  collect_predictions() |>
  conf_mat(truth = Retentie, estimate = .pred_class) 

dfConf_matrix <- as_tibble(confusion_matrix$table) |>
  rename(Werkelijkheid = Truth) |>
  mutate(Werkelijkheid = ifelse(Werkelijkheid == "TRUE", "Retentie", "Geen retentie"),
         Prediction    = ifelse(Prediction == "TRUE", "Retentie", "Geen retentie"))

pTP  <- Change_Number_Marks((dfConf_matrix$n[4]/sum(dfConf_matrix$n)*100),1)
pFP  <- Change_Number_Marks((dfConf_matrix$n[2]/sum(dfConf_matrix$n)*100),1)
pTN  <- Change_Number_Marks((dfConf_matrix$n[1]/sum(dfConf_matrix$n)*100),1)
pFN  <- Change_Number_Marks((dfConf_matrix$n[3]/sum(dfConf_matrix$n)*100),1)
pACC <- Change_Number_Marks(Last_fit_Accuracy,1)

```

De prestaties van het model kunnen we verder uitdrukken in een *confusion matrix*. Hierin zien we de voorspellingen van het model en de werkelijke uitkomsten. De matrix geeft inzicht in de mate van correcte en incorrecte voorspellingen. Ter illustratie werken we de matrix uit voor een voorspelling waarop een bindend studieadvies (BSA) gebaseerd zou kunnen zijn.

```{r}
#| label: fig-confusion-matrix-explanation
#| fig-cap: "Confusion matrix in relatie tot BSA"

knitr::include_graphics(here::here("R/images", "confusion-matrix-retention-lta-hhs.png"))

```

We passen de confusion matrix nu toe op het model dat als beste naar voren kwam. De **accuraatheid** van dit model is **`r pACC`%**. De accuraatheid van het model berekenen we door de som van de diagonaal te berekenen: het aandeel goed voorspelde uitkomsten, Retentie = Retentie (*True Positive*) en Geen retentie = Geen retentie (*True Negative*), af te zetten tegen het totaal aantal voorspellingen: `r pTP`% + `r pTN`% = `r pACC`%. (NB. De weergave in deze confusion matrix is diagonaal gespiegeld vergeleken met het voorbeeld.)

```{r}
#| label: fig-confusion-matrix-actual
#| fig-cap: !expr 'paste("Confusion matrix ten opzichte van", params$succes)'
 
confusion_plot <- plot_confusion_matrix(
    dfConf_matrix,
    target_col = "Werkelijkheid",
    prediction_col = "Prediction",
    counts_col = "n",
    palette = "Blues",
    add_sums = TRUE,
    theme_fn = ggplot2::theme_light,
    sums_settings = sum_tile_settings(
      palette = "Greens",
      label = "Totaal",
      tc_tile_border_color = "black"
    )) +
    
    # Customize the labels
    labs(
      x = "Werkelijke uitkost",
      y = "Voorspelde uitkomst",
      caption = sCaption
    ) +
    
    Set_Theme()
  
  # Add theme elements
  confusion_plot <- Add_Theme_Elements(confusion_plot, 
                                           title_subtitle = TRUE)
  
  print(confusion_plot)
  
```

### Uitleggen of verklaren?

Naast de accuraatheid van het model is het ook belangrijk om te weten welke factoren het meest bijdragen aan de voorspelling van `r tolower(sSucces_model)`. Daarin gaat de vergelijking met de prestaties van het basemodel mank. Dat model geeft op geen enkele manier aan waarom een student een kans op succes heeft, anders dan - 'dit is gebruikelijk in deze opleiding'.

Ongeacht de mate van accuraatheid, is het voor onderzoek naar kansengelijkheid essentieel om te weten welke factoren het meest bijdragen aan de voorspelling van `r tolower(sSucces_model)`. Het gaat erom dat we het belang van de factoren in de voorspellingen kunnen begrijpen en duiden. Machine Learning is hiervoor uitstekend geschikt, omdat het de mogelijkheid biedt om de belangrijkste factoren en hun invloed te leren kennen [@Shmueli.2010; @Shmueli.2011].

<!-- -   `r sConclusie_text` -->

<!-- FOOTER -->

<!-- Justification -->

::: {.content-hidden unless-meta="includes.justification"}
{{< include R/qmd/footer-justification.qmd >}}
:::

<!-- Copyright -->

::: {.content-hidden unless-meta="includes.copyright"}
{{< include R/qmd/footer-copyright.qmd >}}
:::

<!-- Cleaning up -->

```{r}
#| label: cleanup
#| echo: false

# Datasets
rm(
  dfOpleiding_inschrijvingen,
  dfSummary,
  dfRetentie_test,
  dfRetentie_train,
  dfRetentie_validation,
  splits
  )

# Logistic regression
if(bInclude_Model_LR) {
  rm(
    lr_auc,
    lr_auc_highest,
    lr_best,
    lr_mod,
    lr_plot,
    lr_recipe,
    lr_res,
    lr_workflow
  )
  # if(sBest_model == "lr") {
  #   rm(last_lr_mod,
  #      last_lr_workflow)
  # }
}

# Random Forest
if(bInclude_Model_RF) {
  rm(
    rf_auc,
    rf_auc_highest,
    rf_best,
    rf_mod,
    rf_recipe,
    rf_res,
    rf_workflow,
    last_rf_mod,
    last_rf_workflow
  )
  # if(sBest_model == "rf") {
  #   rm(last_rf_mod,
  #      last_rf_workflow)
  # }
}

# Final Fit
if(bInclude_Final_fit) {
  rm(
    last_fit
  )
}

# Conclusions
if(bInclude_Conclusies) {
  rm(
    top_models,
    dfTop_vi,
    lTop3_vi,
    lTop45_vi
    )
}

# Collect garbage
invisible(gc())
  
```
