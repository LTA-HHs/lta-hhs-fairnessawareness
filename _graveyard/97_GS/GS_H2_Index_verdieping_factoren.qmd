---
title: "Prognosemodel retentie na 1 jaar (Gewogen) - Factoren"
subtitle: "`r params$faculteit` | `r params$opleidingsnaam` (`r params$opleiding`) - `r params$opleidingsvorm` - versie `r params$versie`"

## Auteur en datum
author: "Theo Bakker, lector Learning Technology & Analytics, De HHs"
date: last-modified

## LTA Template
ltatemplate: 0.9.1.9000

## Format en output
output-file: "lta-hhs-tidymodels-retentie-verdieping-factoren-gewogen.html"

## Parameters        
params:
  versie: "1.0"
  succes: "Retentie na 1 jaar"
  propedeusediploma: "Nvt" ## Nvt/Met P/Zonder P
  
  ## Recreate plots
  recreateplots: true
  
  ## BRV:ORM DT
  faculteit: "BRV"
  opleidingsnaam: "B Bestuurskunde Overheidsmanagement"
  opleiding: "BO"
  opleidingsvorm: "duaal"
  opleidingsvorm_afkorting: "DU"
  selectie: false
  
  
  ## Author
  author: "Theo Bakker, lector Learning Technology & Analytics"
  
## Content
includes:
  inleiding:      true
  data:           true
  model_lr:       true
  model_rf:       true
  model_svm:      false
  final_fit:      true
  conclusies:     true
  verantwoording: true
  nextsteps:      true
  copyright:      true
---

<!-- Title -->

# Analyse van factoren {#sec-factoranalyse}

```{r setup, include = FALSE}
#| label: setup
#| echo: false

## Sluit het _Setup.R bestand in
source("_Setup.R")

```

<!-- Inleiding -->

## Inleiding

<!-- Data -->

## Voorbereidingen

### Laad de data

We laden de bewerkte data en prognosemodellen in voor:

**Opleiding**: `r params$faculteit` \| `r params$opleidingsnaam` (`r params$opleiding`), `r params$opleidingsvorm`, eerstejaars - **`r sSucces_model`**

```{r}
#| label: load_data

## Bepaal de paden
sData_outputpath           <- Get_Model_Outputpath(mode = "data")
sFittedmodels_outputpath   <- Get_Model_Outputpath(mode = "last-fits")
sModelresults_outputpath   <- Get_Model_Outputpath(mode = "modelresults")

## Laad de data voor de opleiding: data, last fits en model results
dfOpleiding_inschrijvingen <- rio::import(sData_outputpath, trust = TRUE)
lLast_fits                 <- rio::import(sFittedmodels_outputpath, trust = TRUE)
dfModel_results            <- rio::import(sModelresults_outputpath, trust = TRUE)

# Pas de Retentie variabele aan naar numeric (0/1), 
# zodat er een explainer van gemaakt kan worden
dfOpleiding_inschrijvingen$Retentie <- as.numeric(dfOpleiding_inschrijvingen$Retentie) - 1

## Maak een lijst van dfPersonas
lDfPersona <- list()

## Loop over de variabelen
lDfPersona <- map(c("Geslacht", "Vooropleiding", "Aansluiting"),
                  ~ Get_dfPersona(.x)) |>
  set_names(c("Geslacht", "Vooropleiding", "Aansluiting"))

## Laad de persona's
dfPersona_all <- Get_dfPersona()

```

## Verdiepende analyse van het model

### Maak een explainer

We gaan nu een stap verder met behulp van het `DALEX` package. Op basis van het tidymodels model extraheren we de informatie voor de explainer van Dalex.

```{r, include=FALSE}
#| label: fitted_model

sBest_model <- dfModel_results$model[dfModel_results$number == 1]
last_fit    <- lLast_fits[[sBest_model]]

fitted_model <- last_fit |>
  extract_fit_parsnip()

## Controleer of de coefficienten van het model numeriek zijn
coefs <- tidy(fitted_model)$estimate

# Controleer of de coëfficiënten numeriek zijn
if (!is.numeric(coefs)) {
  stop("De geëxtraheerde coëfficiënten zijn niet numeriek.")
}

```

```{r}
#| label: lf_explainer

## Extraheer het fitted model en de workflow
fitted_model <- last_fit |>
  extract_fit_parsnip()

workflow <- last_fit |>
  extract_workflow()

# Maak een explainer
explain_lf <- DALEX::explain(
  model = workflow,
  data = dfOpleiding_inschrijvingen,
  y = dfOpleiding_inschrijvingen$Retentie,
  label = "Linear Regression", 
  weights = dfOpleiding_inschrijvingen$Gewicht)

```

### Toets de Root Mean Square Error na permutaties

De meeste voorspellende factoren en hun RMSE zijn:

```{r}
#| label: lf_model_parts

sPlotPath <- file.path(Get_Plot_Outputpath(plotname = "lf_model_parts_rmse"))

## Als de plot niet bestaat of als recreateplots - T, maak dan een nieuwe plot
if(!file.exists(sPlotPath) | params$recreateplots == TRUE) {

  ## Bereken de model parts op basis van de RMSE
  mp_rmse <- model_parts(explain_lf, loss_function = loss_root_mean_square)
  
  ## Maak een plot van de RMSE
  mp_rmse_plot <- Get_RMSE_Plot(mp_rmse)
  
  ## Bewaar de plot
  suppressWarnings(
    Finalize_Plot(
      plot_name = mp_rmse_plot,
      save_filepath = sPlotPath,
      height_pixels = 50 + (15 * length(unique(mp_rmse$variable)))
    ))

  # ## Toon de bestaande plot
  knitr::include_graphics(sPlotPath)
      
} else {
  
  ## Toon de bestaande plot
  knitr::include_graphics(sPlotPath)
  
}
```

### Inspecteer variabelen met de meeste invloed

```{r}
#| label: lf_break_down_all
#| echo: false
#| results: asis

## Maak een breakdown van de meeste voorkomende student over alle data
breakdown_lf_all <- predict_parts(explainer = explain_lf,
                                  new_observation = dfPersona_all[1, ],
                                  type = "break_down")

## Bereken de intercept
nIntercept <- breakdown_lf_all |> 
  filter(variable == "intercept") |>
  pull(cumulative) * 100 |> 
  round(1) 

sIntercept <- Change_Number_Marks(nIntercept, digits = 1)

```


#### De meest voorkomende student (totaal)


```{r}
#| label: lf_break_down_distribution_all
#| echo: false
#| results: asis

## Bepaal de plot
sPlotPath <- file.path(Get_Plot_Outputpath(plotname = "lf_break_down_distribution_all"))

## Als de plot niet bestaat of als recreateplots - T, maak dan een nieuwe plot
if(!file.exists(sPlotPath) | params$recreateplots == TRUE) {

  ## Bepaal de algemene persona en de breakdown (met distributie)
  breakdown_lf_all <- predict_parts(explainer = explain_lf,
                                    new_observation = dfPersona_all[1, ],
                                    type = "break_down",  
                                    keep_distributions = TRUE)
  
  ## Bepaal de dataframe voor de breakdown
  dfBreakdown_lf_all <- Get_dfBreakdown_Lf(breakdown_lf_all)
  
  ## Bepaal de titels
  lTitles <- Get_Breakdown_Titles(breakdown_lf_all, dfPersona_all, 1, 
                                  "Alle studenten", "Alle studenten",
                                  mode = "all")
  
  ## Bouw de plot
  breakdown_plot <- Get_Breakdown_Plot_All(breakdown_lf_all, 
                                           lTitles)
    
  ## Sla de plot op
  suppressWarnings(
    Finalize_Plot(
          plot_name = breakdown_plot,
          save_filepath = sPlotPath,
          height_pixels = 50 + (20 * length(breakdown_lf_all$variable))
        )
    )

  
  ## Toon de bestaande plot
  knitr::include_graphics(sPlotPath)

} else {

  ## Toon de bestaande plot
  knitr::include_graphics(sPlotPath)

}

```

#### De meest voorkomende student (per groep)


```{r}
#| label: lf_break_down
#| echo: false
#| results: asis

## Loop over de persona's
for(group in names(lDfPersona)) {
  
  ## Laad de dataset voor de huidige persona
  dfPersona <- lDfPersona[[group]]
  
  ## Print de naam van lDfPersona als header
  Knit_Header(glue("Naar {tolower(group)}"), 5)
  
  ## Bepaal of er in de dataset een groep is met minder dan 21 studenten;
  ## Zo ja, laat die buiten beschouwing en meld dit
  if (any(dfPersona$Subtotaal < 21)) {
    
    ## Bepaal de categorieën met minder dan 21 studenten
    lCategorie_te_laag <- dfPersona |>
      filter(Subtotaal < 21) |>
      pull(Categorie) 
    
    ## Bepaal de tekst voor de melding
    if(length(lCategorie_te_laag) > 1) {
      .categorieen  <- paste0(head(lCategorie_te_laag, 
                                   length(lCategorie_te_laag) - 1), " en ", 
                              tail(lCategorie_te_laag, 1))
      .subtotalen   <- "De subtotalen voor de categorieën"
      .persoonsvorm <- "zijn"
    } else {
      .categorieen  <- lCategorie_te_laag
      .subtotalen   <- "Het subtotaal voor de categorie"
      .persoonsvorm <- "is"
    }
    
    ## Print de melding
    Knit_Print_Rule(glue("{(.subtotalen)} {(.categorieen)} {(.persoonsvorm)} te laag voor een betrouwbare analyse."))
  }
  
  ## Open een panel-tabset
  Knit_Print_Rule(glue("::: {.panel-tabset}", 
                       .open = "{{", 
                       .close = "}}"))
  
  ## Bepaal de sorteervolgorde van de variabelen
  if(group == "Geslacht") {
    lArrange <- c("M", "V")
  } else if (group == "Vooropleiding") {
    lArrange <- lLevels_vop
  } else if (group == "Aansluiting"){
    lArrange <- lLevels_aansluiting
  }
  
  # Sorteer de persona op basis van de levels van de categorie
  dfPersona <- dfPersona |> 
    arrange(match(Categorie, lArrange))
  
  # Loop over de persona's
  for(j in 1:nrow(dfPersona)) {
    
    ## Bepaal de huidige student
    student_current   <- dfPersona[j, ]
    student_groep     <- student_current$Groep
    student_categorie <- dfPersona[j, ]$Categorie # levels(student_current[[student_groep]])[j]
    
    ## Bepaal de plotnaam
    sPlotPath <- Get_Breakdown_Plotpath(student_groep, student_categorie)
    
    ## Als het subtotaal < 21, ga dan door naar het volgende item
    if (as.numeric(dfPersona[j, 'Subtotaal']) < 21) {
      next
    }
    
    ## Als recreateplots == T, maak dan een nieuwe plot
    if(params$recreateplots) {
      
      ## Bepaal de breakdown voor de huidige student
      breakdown_lf <- predict_parts(explainer = explain_lf,
                                    new_observation = student_current,
                                    type = "break_down")
      
      dfBreakdown_lf <- Get_dfBreakdown_Lf(breakdown_lf)
      
      ## Toon de header
      Knit_Header(student_categorie, 5)
      
      ## Functie om de titels te bepalen
      lTitles <- Get_Breakdown_Titles(breakdown_lf, dfPersona, j, 
                                      student_groep, student_categorie)
      
      # Watervalplot met ggplot
      plot <- Get_Breakdown_Plot(dfBreakdown_lf, lTitles)
      
      ## Sla de plot op
      suppressWarnings(
        Finalize_Plot(
          plot_name = plot,
          save_filepath = sPlotPath,
          height_pixels = 50 + (20 * length(breakdown_lf$variable))
        ))
      
      ## Toon de bestaande plot
      sPlot <- glue("![]({sPlotPath})")
      Knit_Print_Rule(sPlot)
      
    } else {
      
      ## Toon de header
      Knit_Header(student_categorie, 5)
      
      ## Toon de bestaande plot
      sPlot <- glue("![]({sPlotPath})")
      Knit_Print_Rule(sPlot)
      
    }
    
  }
  
  ## Sluit de panel-tabset
  Knit_Print_Rule(":::")
  
}

```

### Shapley

```{r}
#| label: lf_shapley

## Bewaar de plot
sPlotPath <- file.path(Get_Plot_Outputpath(plotname = "lf_shapley"))

## Als de plot niet bestaat of als recreateplots - T, maak dan een nieuwe plot
if(!file.exists(sPlotPath) | params$recreateplots == TRUE) {

  ## Bepaal de Shapley waarden
  lf_shapley <- 
    predict_parts(
      explainer = explain_lf,
      new_observation = dfPersona_all[1, ],
      type = "shap",
      B = 20
    )

  ## Zet deze om naar een dataframe
  dfShapley <- Get_dfShapley(lf_shapley)

  ## Bouw de plot
  shapley_plot <- Get_Shapley_Plot(dfShapley)
  
  ## Sla de plot op
  suppressWarnings(
    Finalize_Plot(
      plot_name = shapley_plot,
      save_filepath = sPlotPath,
      height_pixels = 50 + (20 * length(unique(dfShapley$variable_name)))
    ))
  
  ## Print de bestaande plot
  knitr::include_graphics(sPlotPath)

} else {

  ## Print de bestaande plot
  knitr::include_graphics(sPlotPath)

}

```

<!-- Scenarios -->

### What-if: een Ceteris Paribus analyse

```{r}
#| label: lf_cp_all
#| echo: false
#| results: asis

library(ingredients)

## Bepaal de meest voorkomende studenten
student_all <- dfPersona_all[1, ] |> as.data.frame()

dfPersona_tmp <- bind_rows(lDfPersona)
student_m    <- dfPersona_tmp[1, ]
student_v    <- dfPersona_tmp[2, ]
student_mbo  <- dfPersona_tmp[3, ]
student_havo <- dfPersona_tmp[4, ]
student_vwo  <- dfPersona_tmp[5, ]

## Maak variabelen splits voor elke continue
variable_splits = list(
  Leeftijd = seq(
    min(dfOpleiding_inschrijvingen$Leeftijd),
    max(dfOpleiding_inschrijvingen$Leeftijd),
    1
  ),
  Cijfer_CE_VO = seq(0, 10, 0.5),
  Cijfer_CE_Wiskunde = seq(0, 10, 0.5),
  SES_Totaal = seq(
    min(dfOpleiding_inschrijvingen$SES_Totaal),
    max(dfOpleiding_inschrijvingen$SES_Totaal),
    0.1
  ),
  Aanmelding = seq(
    min(dfOpleiding_inschrijvingen$Aanmelding),
    max(dfOpleiding_inschrijvingen$Aanmelding),
    1
  )
)

for (group in c("Geslacht", "Vooropleiding", "Aansluiting")) {
  
  ## Als recreateplots == T, maak dan een nieuwe plot
  if(params$recreateplots) {
  
    ## Bewaar de plot
    sPlotPath <- file.path(Get_Plot_Outputpath(plotname = paste0("lf_cp_", tolower(group))))
    
    Knit_Header(group, 4)
  
    ## Maak een breakdown van de meeste voorkomende student over alle data
    if(group == "Geslacht") {
      .new_observation <- dfPersona_tmp |>
        filter(Groep == "Geslacht") |> 
        arrange(match(Geslacht, c("M","V")))
    } else if(group == "Vooropleiding") {
      .new_observation <- dfPersona_tmp |>
        filter(Groep == "Vooropleiding",
               Vooropleiding %in% c("MBO", "HAVO", "VWO")) |>
        arrange(match(Vooropleiding, c("MBO", "HAVO", "VWO")))
    } else if(group == "Aansluiting") {
      .new_observation <- dfPersona_tmp |>
        filter(Groep == "Aansluiting") |>
        arrange(match(
          Aansluiting,
          c("Direct",
            "Tussenjaar",
            "Switch",
            "Na CD",
            "Overig",
            "Onbekend")
        ))
    }
    
    ## Maak een ceteris paribus analyse
    cp_lf_all <- predict_profile(
      explainer = explain_lf,
      new_observation = .new_observation,
      variable_splits = variable_splits
    )

    ## Maak een Ceteris Paribus plot
    cp_plot <- Get_Ceteris_Paribus_Plot(cp_lf_all, group)

    suppressWarnings(
          Finalize_Plot(
            plot_name = cp_plot,
            save_filepath = sPlotPath
          ))

    ## Print de bestaande plot
    sPlot <- glue("![]({sPlotPath})")
    Knit_Print_Rule(sPlot)
    
    } else {
      
      ## Print de bestaande plot
      sPlotPath <- file.path(Get_Plot_Outputpath(plotname = paste0("lf_cp_", tolower(group))))
      sPlot <- glue("![]({sPlotPath})")
      Knit_Print_Rule(sPlot)
  
  } 
}

```

<!-- Partial Dependence -->

### Partial Dependence analyse

```{r}
#| label: lf_pdp_all
#| echo: false
#| results: asis

set.seed(1134)

## Maak een PDP voor alle variabelen. Gebruik de variable_splits die we eerder hebben gemaakt
for (group in c("Alle studenten", "Geslacht", "Vooropleiding", "Aansluiting")) {
  
  ## Als recreateplots == T, maak dan een nieuwe plot
  if(params$recreateplots) {
  
    ## Bewaar de plot
    sPlotPath <- file.path(Get_Plot_Outputpath(plotname = paste0("lf_pdp_",
                                                                 tolower(group))))
    ## Maak een header
    Knit_Header(group, 4)

    if(group == "Alle studenten") {
      
      ## Maak het model profiel
      pdp_lf <- model_profile(explainer = explain_lf,
                              variable_splits = variable_splits)

      ## Maak een Partial Dependence plot
      pdp_plot <- Get_Partial_Dependence_Plot(pdp_lf, "all")
      
      
    } else {
      
      ## Maak het model profiel
      pdp_lf <- model_profile(explainer = explain_lf,
                              variable_splits = variable_splits,
                              groups = group)
      
      ## Maak een Partial Dependence plot per groep
      pdp_plot <- Get_Partial_Dependence_Plot(pdp_lf, group)
      
    }
    
    ## Sla de plot op
    suppressWarnings(
          Finalize_Plot(
            plot_name = pdp_plot,
            save_filepath = sPlotPath
          ))

    ## Print de bestaande plot
    sPlot <- glue("![]({sPlotPath})")
    Knit_Print_Rule(sPlot)
    
    } else {
      
      ## Maak een header
      Knit_Header(group, 4)
      
      ## Print de bestaande plot
      sPlotPath <- file.path(Get_Plot_Outputpath(plotname = paste0("lf_pdp_",
                                                                   tolower(group))))
      sPlot <- glue("![]({sPlotPath})")
      Knit_Print_Rule(sPlot)
      
    }
  }

```

<!-- Next steps -->

## Vervolgstappen: kansengelijkheid

De volgende stap (stap 3) is te onderzoeken of er binnen deze opleiding binnen deze modellen **kansengelijkheid** bestaat.

Dit doen we door de metrieken van de modellen te evalueren voor verschillende groepen studenten, zoals accuraatheid. Als de metrieken van de voorspellingen van het model voor verschillende groepen studenten sterk uiteenloopt kan er sprake zijn van een bias en duiden op kansenongelijkheid. Dit is het onderwerp van de volgende en laatste analyse.

<!-- Verantwoording -->

```{r, echo=FALSE, results='asis'}
sQuarto_version <- quarto::quarto_version()
```

 

**Verantwoording**

Deze analyse maakt deel uit van het onderzoek naar kansengelijkheid van het lectoraat Learning Technology & Analytics van De Haagse Hogeschool: [No Fairness without Awareness](https://www.dehaagsehogeschool.nl/onderzoek/kenniscentra/no-fairness-without-awareness) \| Het rapport is door het lectoraat ontwikkeld in [Quarto](https://quarto.org/) `r sQuarto_version`. \| Template versie: `r rmarkdown::metadata$ltatemplate`

<!-- Copyright -->

```{r, echo=FALSE, results='asis'}
nCurrent_year   <- as.numeric(format(Sys.Date(), "%Y"))
```

 

**Copyright**

Dr. Theo Bakker, Lectoraat Learning Technology & Analytics, De Haagse Hogeschool © 2023-`r nCurrent_year`. Alle rechten voorbehouden.

<!-- Opschonen -->

```{r, echo = FALSE}
#| label: cleanup

## Datasets


## Collect garbage
invisible(gc())
  
```
